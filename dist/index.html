<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Local Drop — Receiver</title>
    <meta name="description" content="Local network file transfer — no cloud, no signup." />
    <link rel="icon" href="/local-drop-favicon.png" type="image/png" />
    <style>
      :root{--bg:#0f1724;--card:#0b1220;--accent:#7c5cff;--muted:#9aa4b2;--glass:rgba(255,255,255,0.04)}
      html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#071029 0%, #0f1724 100%);color:#e6eef8}
      .wrap{max-width:980px;margin:32px auto;padding:28px;border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(2,6,23,0.6)}
      h1{margin:0 0 6px;font-size:20px}
      p.lead{margin:0 0 18px;color:var(--muted)}
      .grid{display:grid;grid-template-columns:1fr 380px;gap:18px}
      .card{background:var(--card);padding:16px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
      .controls{display:flex;gap:8px;flex-wrap:wrap}
      button{background:var(--accent);color:white;border:0;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer}
      button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
      .status{padding:8px 10px;border-radius:8px;background:var(--glass);font-size:14px;color:var(--muted)}
      .logs{height:320px;overflow:auto;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:8px;font-family:monospace;font-size:12px}
      .option-grid{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
      .option-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
      .option-btn:hover{border-color:var(--accent);color:white}
      .file-row{display:flex;gap:8px;align-items:center}
      progress{width:100%;height:12px;border-radius:6px}
      .muted{color:var(--muted);font-size:13px}
      @media(max-width:900px){.grid{grid-template-columns:1fr;}}
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Local Drop</h1>
      <p class="lead">Transfer files directly on your LAN. Connect, verify on the Android device, then establish a WebRTC DataChannel to send files.</p>

      <div class="grid">
        <div class="card">
          <h3>Signaling & Verification</h3>
          <div style="display:flex;gap:10px;margin-top:12px;align-items:center">
            <button id="connectBtn">Connect WebSocket</button>
            <div id="wsState" class="status">WS: disconnected</div>
            <div id="ipCopy" style="margin-left:auto"><button class="ghost" id="copyUrlBtn">Copy URL</button></div>
          </div>

          <div id="verificationCard" style="margin-top:14px">
            <div class="muted">Verification</div>
            <div id="verificationSection" style="display:none;margin-top:8px">
              <div class="option-grid" id="verifyOptions"></div>
              <div class="muted" style="margin-top:8px">Enter the code shown on your Android device.</div>
            </div>
            <div id="authState" class="status" style="margin-top:8px">Auth: pending</div>
          </div>

          <hr style="border:none;height:1px;background:rgba(255,255,255,0.02);margin:16px 0">

          <h3>WebRTC</h3>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <button id="webrtcBtn" disabled>Start WebRTC</button>
            <div id="rtcState" class="status">RTC: idle</div>
            <div class="muted" style="margin-left:auto">Ping/Pong: <span id="pingState">waiting</span></div>
          </div>

          <div style="margin-top:12px">
            <input id="fileInput" type="file" />
            <button id="sendFileBtn" disabled style="margin-left:8px">Send File</button>
            <div style="margin-top:8px"><progress id="fileProgress" value="0" max="100"></progress></div>
            <div id="fileProgressText" class="muted" style="margin-top:6px">Upload: idle</div>
          </div>
        </div>

        <div class="card">
          <h3>Activity & Logs</h3>
          <div style="display:flex;gap:8px;margin-bottom:10px;align-items:center">
            <button id="clearLogsBtn" class="ghost">Clear Logs</button>
            <div style="flex:1"></div>
            <div class="muted">Status: <span id="filesCount">ready</span></div>
          </div>
          <div id="logs" class="logs"></div>
        </div>
      </div>
    </div>

    <script>
      // Simple frontend client for the Local Drop signaling + WebRTC flow
      let ws = null;
      let pc = null;
      let dataChannel = null;
      let remoteDescriptionSet = false;
      let pendingCandidates = [];

      const host = window.location.hostname;
      const port = window.location.port || '8080';

      function log(msg){
        const el = document.getElementById('logs');
        const line = document.createElement('div');
        line.textContent = (new Date()).toLocaleTimeString() + ' - ' + msg;
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
        console.log(msg);
      }

      document.getElementById('connectBtn').addEventListener('click', connectWebSocket);
      document.getElementById('webrtcBtn').addEventListener('click', startWebRtc);
      document.getElementById('sendFileBtn').addEventListener('click', sendSelectedFile);
      document.getElementById('clearLogsBtn').addEventListener('click', ()=>{document.getElementById('logs').innerHTML='';});
      document.getElementById('copyUrlBtn').addEventListener('click', ()=>{ navigator.clipboard.writeText(location.href).then(()=>alert('URL copied'))});

      function connectWebSocket(){
        if (ws && ws.readyState === WebSocket.OPEN) return;
        const url = `ws://${host}:${port}/ws`;
        ws = new WebSocket(url);
        document.getElementById('wsState').textContent = 'WS: connecting';

        ws.onopen = ()=>{
          document.getElementById('wsState').textContent = 'WS: connected';
          log('WebSocket connected to ' + url);
        }

        ws.onmessage = async (ev)=>{
          log('WS raw: ' + ev.data);
          let msg = null;
          try{ msg = JSON.parse(ev.data);}catch(e){ log('WS: non-json message'); return; }

          if(msg.type === 'verification_challenge'){
            document.getElementById('verificationSection').style.display = 'block';
            const container = document.getElementById('verifyOptions'); container.innerHTML='';
            (msg.options || []).forEach(opt=>{
              const b = document.createElement('button'); b.className='option-btn'; b.textContent = (opt<10? '0'+opt: opt);
              b.onclick = ()=> sendVerification(opt);
              container.appendChild(b);
            });
            document.getElementById('authState').textContent = 'Auth: choose code';
          } else if(msg.type === 'verification_result' || ('success' in msg)){
            const ok = (msg.success === true);
            document.getElementById('authState').textContent = ok? 'Auth: verified' : 'Auth: failed';
            if(ok){ document.getElementById('webrtcBtn').disabled = false; log('Verification successful'); }
          } else if(msg.type === 'offer'){
            await handleOffer(msg.sdp);
          } else if(msg.type === 'answer'){
            await handleAnswer(msg.sdp);
          } else if(msg.type === 'ice_candidate'){
            handleIce(msg);
          }
        }

        ws.onclose = ()=>{ document.getElementById('wsState').textContent='WS: disconnected'; log('WebSocket closed'); }
        ws.onerror = (e)=>{ document.getElementById('wsState').textContent='WS: error'; log('WebSocket error'); }
      }

      function sendVerification(code){
        if(!ws) return; ws.send(JSON.stringify({type:'verification_response', code})); log('Sent verification response: '+code);
      }

      async function startWebRtc(){
        document.getElementById('rtcState').textContent='RTC: starting';
        document.getElementById('webrtcBtn').disabled = true;
        remoteDescriptionSet = false; pendingCandidates = [];
        ws.send(JSON.stringify({type:'start_webrtc'}));
        log('Requested server to start WebRTC session');
      }

      async function createPeerConnection(){
        if(pc) return pc;
        const conf = {iceServers:[{urls:'stun:stun.l.google.com:19302'}]};
        pc = new RTCPeerConnection(conf);

        pc.onicecandidate = (ev)=>{ if(ev.candidate){ ws.send(JSON.stringify({type:'ice_candidate', candidate:ev.candidate.candidate, sdpMid:ev.candidate.sdpMid, sdpMLineIndex:ev.candidate.sdpMLineIndex})); log('Sent ICE candidate'); }}
        pc.ondatachannel = (ev)=>{ setupDataChannel(ev.channel); }
        pc.onconnectionstatechange = ()=>{ document.getElementById('rtcState').textContent = 'RTC: '+pc.connectionState; log('RTC state: '+pc.connectionState); }
        return pc;
      }

      function setupDataChannel(dc){
        dataChannel = dc; log('DataChannel: '+dc.label);
        dc.onopen = ()=>{ document.getElementById('rtcState').textContent='RTC: connected'; document.getElementById('sendFileBtn').disabled=false; log('DataChannel open'); }
        dc.onmessage = (ev)=>{ log('DC msg: '+ev.data); try{ const p = JSON.parse(ev.data); if(p.type && p.type.startsWith('file_')) log('File message: '+p.type); }catch(e){} if(ev.data==='ping'){ dc.send('pong'); document.getElementById('pingState').textContent='pong'; }}
      }

      async function handleOffer(sdp){ log('Received offer'); await createPeerConnection(); await pc.setRemoteDescription(new RTCSessionDescription({type:'offer', sdp})); remoteDescriptionSet = true; log('Remote description set'); // flush pending
        for(const c of pendingCandidates){ try{ await pc.addIceCandidate(new RTCIceCandidate({candidate:c.candidate,sdpMid:c.sdpMid,sdpMLineIndex:c.sdpMLineIndex})); }catch(e){log('Flush candidate failed:'+e);} }
        pendingCandidates=[];
        const answer = await pc.createAnswer(); await pc.setLocalDescription(answer); ws.send(JSON.stringify({type:'answer', sdp:answer.sdp})); log('Sent answer');
      }

      async function handleAnswer(sdp){ log('Received answer'); if(!pc) await createPeerConnection(); await pc.setRemoteDescription(new RTCSessionDescription({type:'answer', sdp})); remoteDescriptionSet=true; log('Remote answer applied'); }

      function handleIce(msg){ if(!pc || !remoteDescriptionSet){ pendingCandidates.push(msg); log('Queued remote ICE candidate'); return; } try{ pc.addIceCandidate(new RTCIceCandidate({candidate:msg.candidate,sdpMid:msg.sdpMid,sdpMLineIndex:msg.sdpMLineIndex})); log('Added remote ICE candidate'); }catch(e){ log('Failed to add ICE: '+e); } }

      // File sending (simple base64 chunking)
      async function sendSelectedFile(){ const input = document.getElementById('fileInput'); if(!input.files || input.files.length===0) return alert('Select a file'); const file = input.files[0]; if(!dataChannel||dataChannel.readyState!=='open') return alert('DataChannel not open');
        const chunkSize = 16*1024; const total = Math.ceil(file.size/chunkSize); const fileId = Date.now()+'-'+Math.floor(Math.random()*9999);
        dataChannel.send(JSON.stringify({type:'file_meta', fileId, name:file.name, size:file.size, chunkSize, totalChunks:total}));
        for(let i=0;i<total;i++){ const start=i*chunkSize; const end=Math.min(file.size,start+chunkSize); const blob=file.slice(start,end); const arr=await blob.arrayBuffer(); let bin=''; const u=new Uint8Array(arr); for(let j=0;j<u.length;j++) bin+=String.fromCharCode(u[j]); const b64=btoa(bin); dataChannel.send(JSON.stringify({type:'file_chunk', fileId, seq:i, data:b64})); const pct=Math.round(((i+1)/total)*100); document.getElementById('fileProgress').value=pct; document.getElementById('fileProgressText').textContent='Upload: '+pct+'%'; }
        dataChannel.send(JSON.stringify({type:'file_complete', fileId})); document.getElementById('fileProgressText').textContent='Upload: done'; log('File send complete');
      }

      // Enable copy of URL
      (function init(){ log('UI ready');})();
    </script>
  </body>
</html>
